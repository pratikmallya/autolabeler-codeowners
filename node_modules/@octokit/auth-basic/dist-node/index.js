'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var universalUserAgent = require('universal-user-agent');
var request = require('@octokit/request');
var btoa = _interopDefault(require('btoa-lite'));
var requestError = require('@octokit/request-error');

const PATHS = ["/authorizations", "/authorizations/clients/:client_id", "/authorizations/clients/:client_id/:fingerprint", "/authorizations/:authorization_id"]; // CREDIT: Simon Grondin (https://github.com/SGrondin)
// https://github.com/octokit/plugin-throttling.js/blob/45c5d7f13b8af448a9dbca468d9c9150a73b3948/lib/route-matcher.js

function routeMatcher(paths) {
  // EXAMPLE. For the following paths:

  /* [
      "/orgs/:org/invitations",
      "/repos/:owner/:repo/collaborators/:username"
  ] */
  const regexes = paths.map(p => p.split("/").map(c => c.startsWith(":") ? "(?:.+?)" : c).join("/")); // 'regexes' would contain:

  /* [
      '/orgs/(?:.+?)/invitations',
      '/repos/(?:.+?)/(?:.+?)/collaborators/(?:.+?)'
  ] */

  const regex = `^(?:${regexes.map(r => `(?:${r})`).join("|")})[^/]*$`; // 'regex' would contain:

  /*
    ^(?:(?:\/orgs\/(?:.+?)\/invitations)|(?:\/repos\/(?:.+?)\/(?:.+?)\/collaborators\/(?:.+?)))[^\/]*$
       It may look scary, but paste it into https://www.debuggex.com/
    and it will make a lot more sense!
  */

  return new RegExp(regex, "i");
}

const REGEX = routeMatcher(PATHS);
function isAuthorizationRoute(url) {
  return !!url && REGEX.test(url);
}

function isSmsTriggeringRoute(options) {
  return ["PATCH", "PUT", "POST"].includes(options.method) && isAuthorizationRoute(options.url);
}

async function requestWith2Fa(state, options, customRequest) {
  const request = customRequest || state.request;

  try {
    if (state.totp) {
      options = Object.assign({}, options, {
        headers: Object.assign({}, options.headers, {
          "x-github-otp": state.totp
        })
      });
    }

    const response = await request(options);
    return response;
  } catch (error) {
    if (!error.headers) throw error;
    const totpRequired = /required/.test(error.headers["x-github-otp"] || "");
    const hasSmsDelivery = /sms/.test(error.headers["x-github-otp"] || ""); // handle "2FA required" error only

    if (error.status !== 401 || !totpRequired) {
      throw error;
    }

    if (error.status === 401 && totpRequired && error.request.headers["x-github-otp"]) {
      if (state.totp) {
        // TOTP is no longer valid, request again
        delete state.totp;
      } else {
        throw new requestError.RequestError("Invalid TOTP (time-based one-time password) for two-factor authentication", 401, {
          headers: error.headers,
          request: error.request
        });
      }
    } // If user has 2Fa with SMS configured, send a bogus "PATCH /authorizations"
    // request to trigger the TOTP delivery via SMS, unless the current request
    // already triggered a delivery


    if (hasSmsDelivery && !isSmsTriggeringRoute(options)) {
      try {
        await request("PATCH /authorizations", {
          headers: options.headers
        });
      } catch (error) {
        // we expect a 401
        if (error.status !== 401) throw error;
      }
    } // we set state.totp after the request to make sure that it's valid


    const totp = await state.strategyOptions.on2Fa();

    try {
      const response = await requestWith2Fa(state, Object.assign({}, options, {
        headers: Object.assign({}, options.headers, {
          "x-github-otp": totp
        })
      }), customRequest);
      state.totp = totp;
      return response;
    } catch (error) {
      // error without a headers property is an unexpected error
      // which we donâ€™t cover with tests

      /* istanbul ignore next */
      if (!error.headers) throw error;
      const totpRequired = /required/.test(error.headers["x-github-otp"] || ""); // unless the error is an invalid TOTP, we can cache it

      if (!totpRequired) {
        state.totp = totp;
      }

      throw error;
    }
  }
}

async function getToken(state, authOptions, request) {
  if (state.token && !authOptions.refresh) {
    return state.token;
  }

  const basicAuthorization = `basic ${btoa(`${state.strategyOptions.username}:${state.strategyOptions.password}`)}`;
  const timestamp = new Date().toISOString().substr(0, 10);
  const fingerprintDefault = state.strategyOptions.token.note ? undefined : Math.random().toString(36).substr(2);
  const fingerprint = state.strategyOptions.token.fingerprint || fingerprintDefault;
  const note = state.strategyOptions.token.note || `octokit ${timestamp} ${fingerprint}`;
  const scopes = state.strategyOptions.token.scopes || [];
  const noteUrl = state.strategyOptions.token.noteUrl || "https://github.com/octokit/auth-basic.js#readme";
  const options = Object.assign({
    method: "POST",
    url: "/authorizations",
    headers: {
      authorization: basicAuthorization
    },
    note,
    note_url: noteUrl,
    scopes
  }, fingerprint ? {
    fingerprint
  } : null, state.strategyOptions.token.clientId ? {
    client_id: state.strategyOptions.token.clientId,
    client_secret: state.strategyOptions.token.clientSecret
  } : null);
  const {
    data: {
      id,
      token
    }
  } = await requestWith2Fa(state, options, request);
  state.token = {
    type: "token",
    tokenType: "oauth",
    id,
    token,
    username: state.strategyOptions.username
  };
  return state.token;
}

async function auth(state, options = {}) {
  const credentials = btoa(`${state.strategyOptions.username}:${state.strategyOptions.password}`);

  if (options.type === "basic") {
    // send a dummy request to invoke 2Fa authorization. The endpoint does not exist
    // yet triggers 2Fa for both app & sms, see https://git.io/fjPJM
    try {
      await requestWith2Fa(state, {
        method: "PATCH",
        url: "/authorizations",
        headers: {
          authorization: `basic ${credentials}`
        }
      });
    } catch (error) {
      if (error.status !== 404) {
        throw error;
      } // we are expecting a 404 error

    }

    return Object.assign({
      type: "basic",
      username: state.strategyOptions.username,
      password: state.strategyOptions.password,
      credentials
    }, state.totp ? {
      totp: state.totp
    } : null);
  }

  return getToken(state, options);
}

async function hook(state, request, route, parameters) {
  const endpoint = request.endpoint.merge(route, parameters);
  const basicAuthorization = `basic ${btoa(`${state.strategyOptions.username}:${state.strategyOptions.password}`)}`;

  if (isAuthorizationRoute(endpoint.url)) {
    endpoint.headers.authorization = basicAuthorization;
    return requestWith2Fa(state, endpoint, request);
  }

  const {
    token
  } = await getToken(state, {}, request);
  endpoint.headers.authorization = `token ${token}`;
  return request(endpoint);
}

const VERSION = "1.3.0";

const createBasicAuth = function createBasicAuth(options) {
  ["username", "password", "on2Fa"].forEach(option => {
    if (!options.hasOwnProperty(option)) {
      throw new Error(`[@octokit/auth-basic] ${option} option is required`);
    }
  });
  const strategyOptions = Object.assign({
    token: {}
  }, options);
  const state = {
    strategyOptions,
    request: strategyOptions.request || request.request.defaults({
      baseUrl: "https://api.github.com",
      headers: {
        "user-agent": `octokit-auth-basic.js/${VERSION} ${universalUserAgent.getUserAgent()}`
      }
    })
  };
  return Object.assign(auth.bind(null, state), {
    hook: hook.bind(null, state)
  });
};

exports.createBasicAuth = createBasicAuth;
//# sourceMappingURL=index.js.map
