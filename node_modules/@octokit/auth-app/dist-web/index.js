import { getUserAgent } from 'universal-user-agent';
import { request } from '@octokit/request';
import { githubAppJwt } from 'universal-github-app-jwt';
import LRU from 'lru-cache';
import { RequestError } from '@octokit/request-error';

async function getAppAuthentication(id, privateKey) {
    const appAuthentication = await githubAppJwt({ id, privateKey });
    return {
        type: "app",
        token: appAuthentication.token,
        appId: appAuthentication.appId,
        expiresAt: new Date(appAuthentication.expiration * 1000).toISOString()
    };
}

// https://github.com/isaacs/node-lru-cache#readme
function getCache() {
    return new LRU({
        // cache max. 15000 tokens, that will use less than 10mb memory
        max: 15000,
        // Cache for 1 minute less than GitHub expiry
        maxAge: 1000 * 60 * 59
    });
}
async function get(cache, options) {
    const cacheKey = optionsToCacheKey(options);
    const result = await cache.get(cacheKey);
    if (!result) {
        return;
    }
    const [token, expiresAt, repositorySelection, permissionsString, singleFileName] = result.split("|");
    const permissions = options.permissions ||
        permissionsString.split(/,/).reduce((permissions, string) => {
            if (/!$/.test(string)) {
                permissions[string.slice(0, -1)] = "write";
            }
            else {
                permissions[string] = "read";
            }
            return permissions;
        }, {});
    return {
        token,
        expiresAt,
        permissions,
        repositoryIds: options.repositoryIds,
        singleFileName,
        repositorySelection: repositorySelection
    };
}
async function set(cache, options, data) {
    const cacheKey = optionsToCacheKey(options);
    const permissionsString = options.permissions
        ? ""
        : Object.keys(data.permissions)
            .map(name => `${name}${data.permissions[name] === "write" ? "!" : ""}`)
            .join(",");
    await cache.set(cacheKey, [
        data.token,
        data.expiresAt,
        data.repositorySelection,
        permissionsString,
        data.singleFileName
    ]
        .join("|")
        .replace(/\|+$/, ""));
}
function optionsToCacheKey({ installationId, permissions = {}, repositoryIds = [] }) {
    const permissionsString = Object.keys(permissions)
        .sort()
        .map(name => (permissions[name] === "read" ? name : `${name}!`))
        .join(",");
    const repositoryIdsString = repositoryIds.sort().join(",");
    return [installationId, repositoryIdsString, permissionsString]
        .filter(Boolean)
        .join("|");
}

function toTokenAuthentication({ installationId, token, expiresAt, repositorySelection, permissions, repositoryIds, singleFileName }) {
    return Object.assign({
        type: "token",
        tokenType: "installation",
        token,
        installationId,
        permissions,
        expiresAt,
        repositorySelection
    }, repositoryIds ? { repositoryIds } : null, singleFileName ? { singleFileName } : null);
}

async function getInstallationAuthentication(state, options, customRequest) {
    const installationId = (options.installationId ||
        state.installationId);
    if (!options.refresh) {
        const result = await get(state.cache, options);
        if (result) {
            const { token, expiresAt, permissions, repositoryIds, singleFileName, repositorySelection } = result;
            return toTokenAuthentication({
                installationId,
                token,
                expiresAt,
                permissions,
                repositorySelection,
                repositoryIds,
                singleFileName
            });
        }
    }
    const appAuthentication = await getAppAuthentication(state.id, state.privateKey);
    const request = customRequest || state.request;
    const { data: { token, expires_at: expiresAt, repositories, permissions, repository_selection: repositorySelection, single_file: singleFileName } } = await request("POST /app/installations/:installation_id/access_tokens", {
        installation_id: installationId,
        repository_ids: options.repositoryIds,
        permissions: options.permissions,
        mediaType: {
            previews: ["machine-man"]
        },
        headers: {
            authorization: `bearer ${appAuthentication.token}`
        }
    });
    const repositoryIds = repositories
        ? repositories.map((r) => r.id)
        : void 0;
    await set(state.cache, options, {
        token,
        expiresAt,
        repositorySelection,
        permissions,
        repositoryIds,
        singleFileName
    });
    return toTokenAuthentication({
        installationId,
        token,
        expiresAt,
        repositorySelection,
        permissions,
        repositoryIds,
        singleFileName
    });
}

async function getOAuthAuthentication(state, options, customRequest) {
    const request = customRequest || state.request;
    // The "/login/oauth/access_token" is not part of the REST API hosted on api.github.com,
    // instead itâ€™s using the github.com domain.
    const route = /^https:\/\/(api\.)?github\.com$/.test(state.request.endpoint.DEFAULTS.baseUrl)
        ? "POST https://github.com/login/oauth/access_token"
        : `POST ${state.request.endpoint.DEFAULTS.baseUrl.replace("/api/v3", "/login/oauth/access_token")}`;
    const parameters = {
        headers: {
            accept: `application/json`
        },
        client_id: state.clientId,
        client_secret: state.clientSecret,
        code: options.code,
        state: options.state,
        redirect_uri: options.redirectUrl
    };
    const response = await request(route, parameters);
    if (response.data.error !== undefined) {
        throw new RequestError(`${response.data.error_description} (${response.data.error})`, response.status, {
            headers: response.headers,
            request: request.endpoint(route, parameters)
        });
    }
    const { data: { access_token: token, scope } } = response;
    return {
        type: "token",
        tokenType: "oauth",
        token,
        scopes: scope.split(/,\s*/).filter(Boolean)
    };
}

async function auth(state, options) {
    if (options.type === "app") {
        return getAppAuthentication(state.id, state.privateKey);
    }
    if (options.type === "installation") {
        return getInstallationAuthentication(state, options);
    }
    return getOAuthAuthentication(state, options);
}

const PATHS = [
    "/app",
    "/app/installations",
    "/app/installations/:installation_id",
    "/app/installations/:installation_id",
    "/app/installations/:installation_id/access_tokens",
    "/orgs/:org/installation",
    "/orgs/:org/installation",
    "/repos/:owner/:repo/installation",
    "/repos/:owner/:repo/installation",
    "/users/:username/installation",
    "/users/:username/installation"
];
// CREDIT: Simon Grondin (https://github.com/SGrondin)
// https://github.com/octokit/plugin-throttling.js/blob/45c5d7f13b8af448a9dbca468d9c9150a73b3948/lib/route-matcher.js
function routeMatcher(paths) {
    // EXAMPLE. For the following paths:
    /* [
        "/orgs/:org/invitations",
        "/repos/:owner/:repo/collaborators/:username"
    ] */
    const regexes = paths.map(p => p
        .split("/")
        .map(c => (c.startsWith(":") ? "(?:.+?)" : c))
        .join("/"));
    // 'regexes' would contain:
    /* [
        '/orgs/(?:.+?)/invitations',
        '/repos/(?:.+?)/(?:.+?)/collaborators/(?:.+?)'
    ] */
    const regex = `^(?:${regexes.map(r => `(?:${r})`).join("|")})[^/]*$`;
    // 'regex' would contain:
    /*
      ^(?:(?:\/orgs\/(?:.+?)\/invitations)|(?:\/repos\/(?:.+?)\/(?:.+?)\/collaborators\/(?:.+?)))[^\/]*$
  
      It may look scary, but paste it into https://www.debuggex.com/
      and it will make a lot more sense!
    */
    return new RegExp(regex, "i");
}
const REGEX = routeMatcher(PATHS);
function requiresAppAuth(url) {
    return !!url && REGEX.test(url);
}

async function hook(state, request, route, parameters) {
    let endpoint = request.endpoint.merge(route, parameters);
    if (requiresAppAuth(endpoint.url.replace(request.endpoint.DEFAULTS.baseUrl, ""))) {
        const { token } = await getAppAuthentication(state.id, state.privateKey);
        endpoint.headers.authorization = `bearer ${token}`;
        return request(endpoint);
    }
    const { token } = await getInstallationAuthentication(state, {}, request);
    endpoint.headers.authorization = `token ${token}`;
    return request(endpoint);
}

const VERSION = "2.4.2";

const createAppAuth = function createAppAuth(options) {
    const state = Object.assign({
        request: request.defaults({
            headers: {
                "user-agent": `octokit-auth-app.js/${VERSION} ${getUserAgent()}`
            }
        }),
        cache: getCache()
    }, options);
    return Object.assign(auth.bind(null, state), {
        hook: hook.bind(null, state)
    });
};

export { createAppAuth };
//# sourceMappingURL=index.js.map
